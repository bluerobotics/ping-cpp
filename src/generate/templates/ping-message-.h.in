// C++ implementation of the Blue Robotics 'Ping' binary message protocol

//~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!
// THIS IS AN AUTOGENERATED FILE
// DO NOT EDIT
//~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!

#pragma once

#include "ping-message.h"

// TODO: should maybe be an enum
namespace {{definition|capitalize}}Id
{
{% for message_type in messages %}
{% for message in messages[message_type] %}
{% set m = messages[message_type][message] %}
{% set class_name = "%s_%s" % (definition, message) %}
    static const uint16_t {{message|upper}} = {{m.id}};
{% endfor %}
{% endfor %}
};

{% for message_type in messages %}
{% for message in messages[message_type] %}
{% set m = messages[message_type][message] %}
{% set total_payload = generator.calc_payload(m.payload) %}
{% set class_name = "%s_%s" % (definition, message) %}
class {{class_name}} : public ping_message
{
public:
    {{class_name}}(const ping_message& msg) : ping_message { msg } {}
    {{class_name}}(const uint8_t* buf, const uint16_t length) : ping_message { buf, length } {}
    {{class_name}}(
{%- for payload in m.payload %}
{% if generator.is_vector(payload.type) %}
{% if payload.vector.sizetype -%}
            {{generator.get_type_string(payload.vector.sizetype)}} {{payload.name}}_length
{% else -%}
            uint16_t {{payload.name}}_length
{%- endif %}
{% endif %}
{% endfor %}{# each payload field #}
) : ping_message { static_cast<uint16_t>({{8 + total_payload + 2}}
{%- for payload in m.payload %}
{% if generator.is_vector(payload.type) %}
 + {{payload.name}}_length
{%- endif %}
{% endfor %}) }{# each payload field #}

    {
        msgData[0] = 'B';
        msgData[1] = 'R';
        (uint16_t&)msgData[2] = {{total_payload}}
{%- for payload in m.payload %}
{% if generator.is_vector(payload.type) %}
 + {{payload.name}}_length
{%- endif %}
{% endfor %}; // payload size
        (uint16_t&)msgData[4] = {{m.id}}; // ID
        msgData[6] = 0;
        msgData[7] = 0;
    }

{% set byte = namespace(offset=0, func='') %}
{% if m.payload %}
{% for payload in m.payload %}
{% if generator.is_vector(payload.type) %}
{% if payload.vector.sizetype %}
    {{generator.get_type_string(payload.vector.sizetype)}} {{payload.name}}_length() const { return ({{generator.get_type_string(payload.vector.sizetype)}}&)msgData[headerLength + {{byte.offset}}]; }
    //TODO do this in constructor (const)
    void set_{{payload.name}}_length(const {{generator.get_type_string(payload.vector.sizetype)}} {{payload.name}}_length) { ({{generator.get_type_string(payload.vector.sizetype)}}&)msgData[headerLength + {{byte.offset}}] = {{payload.name}}_length;}
{% set byte.offset = byte.offset + generator.get_c_size(payload.vector.sizetype) %}
{% endif %}
    {{generator.get_type_string(payload.vector.datatype)}}* {{payload.name}}() const { return ({{generator.get_type_string(payload.vector.datatype)}}*)(msgData+headerLength+{{byte.offset}}); }
    void set_{{payload.name}}_at(const uint16_t i, const {{generator.get_type_string(payload.vector.datatype)}} data) { ({{generator.get_type_string(payload.vector.datatype)}}&)msgData[headerLength + {{byte.offset}} + i] = data; }
{% else %}
    {{generator.get_type_string(payload.type)}} {{payload.name}}() const { return ({{generator.get_type_string(payload.type)}}&)msgData[headerLength + {{byte.offset}}]; }
    void set_{{payload.name}}(const {{generator.get_type_string(payload.type)}} {{payload.name}}) { ({{generator.get_type_string(payload.type)}}&)msgData[headerLength + {{byte.offset}}] = {{payload.name}}; }
{% set byte.offset = byte.offset + generator.get_c_size(payload.type) %}
{% endif %}
{% endfor %}
{% endif %}
};

{% endfor %}
{% endfor %}
